###################################################
Notes:
Setup issues.
Break down components for the first requirement, how will they need to scale? What functionality can be grouped?
I wanted to be able to test the backend get request, so I set up a mock axios get function with Jest, but I was getting a "RegeneratorRuntime-is-not-defined" error. Turns out Babel transform runtime needs to be installed to test promises.
Once I ran tests on the Axios API call to get hotel data, and have ensured we're targeting the correct address, we're only calling GET once, and we're getting expected data back, I am ready to look at component structure.
After jumping the gun and breaking the app component out into the planned HotelFilterInput and HitelList components on master, I created a feature branch for the rest of the components skeletons. While creating components, I'm continuing
to utilize index.js files to simplify component imports across the app. While building out the component skeletons, I decided to combine the HotelBackendError and HotelFilterError components into one HotelError component with a passed error prop, 
which will allow the component to be used for other errors should the need arise.
I utilized the example API data to create a mock api dataset for unit tests. I'm implementing this in unit tests in the hotel-input services, and through a test and debug flag in App on the initial API call so that I can avoid calling the live API 
while building out the component structure since react re-renders on change. This will allow me to take advantage of viewing the live frontend changes without spamming the public API.
I started structuring the hotel-input-services, then decided to diverge to js function exports instead of using the new angular service structure since I am familiar with that. At this point I set up some on render tests and ran them, at which point
I encountered two failures in my HotelList and HotelCard components because they both experience exceptions since they are rendering API data which is not passed in the test. In order to resolve this, I passed the test API data on props to the tested component.
In order to efficiently test inputs and outputs from my mock data in jest, I set up static arrays of what the data is expected to be. This ended up working great to organize different unit tests to cover many different pieces of the code and keep inputs and outputs grouped together while maintaining scalability of the tests.
After I finished building out the Input sort and filter function tests, I wrote the input UI in the HotelFilterInput component. A bit rusty on react state management without redux, and I had to refactor some of the tests to maintain data structure consistency with the actual app hotel data passed on props to children.
Getting the components to render properly took a bit of effort, I decided to forgo any useEffect hooks and stuck to event controlled functions, which worked great! While testing various input methods, I discovered that it is necessary in my implementation to
nest the filter function inside the sort function. This was required because the filter function calls the full hotel data prop each time. I'm calling the full hotel data prop because I need to regain hotels that were previously filtered out if I backspace the input. Future implementation
might use the useRefs hook to store the previous sorted arrays to avoid calling the hotel prop each time I filter.

###################################################
Issues:

Error:
I received an error: 

"Cannot read property 'length' of undefined
 at lineCounter (C:\Users\Nate\Documents\Programs\react-frontend-homework\node_modules\parcel-bundler\src\utils\lineCounter.js:3:30)" 

When attempting npm start


Resolution: 
I deleted .cache directory in the root project folder and re-ran npm start.


Error:
When running docker build -t rocketmiles/react-backend-api . I received an error:

"#9 [build 4/4] RUN ./gradlew build --no-daemon
#9 sha256:c3477be12699aec7ae00b14ea7d916ba08a59ae08757c3d95c062ad266717fc6
#9 0.179 /usr/bin/env: ‘sh\r’: No such file or directory
#9 ERROR: executor failed running [/bin/sh -c ./gradlew build --no-daemon]: exit code: 127"

Resolution:

Installed gradle 7.0.2 for winx64 on host PC, set up gradle env var, and ran "gradle wrapper" from gitbash to init gradle daemon.


###################################################
Component Tree:

App
	HotelFilterInput
		HotelList
			HotelCard
		HotelError
	HotelError
			
	Reasoning: 

	HotelList as a child of HotelFilterInput: the list displayed directly depends on the filters input by the user, 
				so as the input state changes, we want to re-render the list each time based on our filter/sort results.
	HotelCard as a child of HotelList: HotelCard will contain select button which will display/un-display additional data based on local state, 
				so I want this scoped to its own component to avoid unnecessary re-renders of HotelList due to the localstate change.
	HotelError renders on App conditionally if the API GET request returns HTTP 500 to fail gracefully to the user.
	HotelError renders on HotelFilterInput conditionally if the filter returns no results to fail gracefully to the user.

###################################################
Component Details:

App
	hotelList populated by API Get request on import when the app is rendered.
	Conditional { hotelList ? HotelFilterInput : HotelBackendError}
	HotelError renders conditionally if the API Get request fails.
	HotelFilterInput Component which receives the hotelList as a prop from App.
	
	Reasoning:	
		We can render it here because the master list of hotels available to the user shouldn't change. In this way, we make one initial API call when App is rendered.
		Handle filtering by passing the data on props to the HotelFilterInput component, creating a filtered and sorted array in that component, and then passing that array down to list.
	
HotelFilterInput
	Input LocalStates
		nameFilterInput (default empty string), sortSelect (default "Recommended"), 
		
	Local const:
		filteredSortedHotelList -> filter function will run on each render
	User Inputs
		Input Field: Hotel Name Filter
			event - sets nameFilterInput
		Select: Price Recommended (Default), ASC, DESC
			event - sets sortSelect
		Reset Button
			onClick - calls Reset function that sets localstates of inputs to default.
			
	Filter and Sort functionality handled here. How?
		1. Filter: pass the filteredSortedList local state and the nameFilterInput string entered by user 
		2. Sort: pass the filteredSortedHotelList local state and the sortSelect entered by user
	Conditional { results ? HotelList Component {filteredSortedHotelList} : HotelFilterError} - if our filtered or sorted lists return nothing, we need to fail gracefully, else pass the filteredSortedHotelList on props.
	
	
HotelList
	Map the passed filterList prop from HotelFilterInput into HotelCard components
	
HotelCard
	Data
        hotels.hotelStaticContent.name etc
	Select
		button onClick function to display extra data

HotelError
	Display the error info from the passed prop and a button to prompt the user to reset the filters and retry the API call. 
	
###################################################
User Inputs:
Hotel Name
	input character event - filter the list of hotels by results.hotels.hotelStaticContent.name
		use Array.filter method here?
Hotel Sort Select
	onSelect event - sort HotelList by results.hotels.lowestAveragePrice both ASC (low to high) and DESC (high to low)
		use Array.sort method here?
Reset
	onClick event - reset the user input states to default.
		ensure the HotelList component re-renders so we map through each HotelCard hotel again.
Select
	onClick event - Display additional API data in the relevant hotel card to client.
Cancel/Unselect
	onClick event - Un-select the additional API data in the relevant hotel card.

###################################################
State Requirements:
HotelCard
	isSelected
HotelFilterInput
	nameFilterInput
	sortSelect